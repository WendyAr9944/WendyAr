// mainwindow.cpp
#include "mainwindow.h"
#include "tower.h"
#include "enemy.h"
#include "bullet.h"
#include "obstacle.h"
#include <QPainter>
#include <QTimer>
#include <QMessageBox>
#include <QMouseEvent>

// 主窗口类的构造函数实现
mainwindow::mainwindow(QWidget *parent)
    : QWidget(parent), currentWave(0), elapsedTime(0), isGameOver(false), showButtons(false), gameSpeed(1), selectedTower(nullptr), selectedObstacle(nullptr)
{
    ui = new Ui::mainwindow;
    ui->setupUi(this);
    // 加载游戏地图图片
    mapPixmap.load(":/images/images/map2.png");
    setFixedSize(1200, 800);
    // 启动定时器，每隔100毫秒触发一次定时器事件
    waveTimerId = startTimer(100);
    // 创建萝卜对象
    radish = new Radish(QPoint(800, 600));
    // 加载游戏结束图片
    gameOverPixmap.load(":/images/images/game_over.png");
    // 创建金钱管理对象，初始金钱为450
    money = new Money(450);
    // 加载金币图标
    coinPixmap.load(":/images/images/coin.png");

    // 加载各种按钮的正常状态图片
    QPixmap pauseNormalPixmap(":/images/images/pause_normal.png");
    QPixmap pauseHoverPixmap(":/images/images/pause_hover.png"); // 新增悬停图片加载
    QPixmap doubleSpeedNormalPixmap(":/images/images/double_speed_normal.png");
    QPixmap doubleSpeedHoverPixmap(":/images/images/double_speed_hover.png"); // 新增悬停图片加载
    QPixmap cannonButtonPixmap(":/images/images/cannon_button.png");
    QPixmap poopButtonPixmap(":/images/images/poop_button.png");
    QPixmap starButtonPixmap(":/images/images/star_button.png");
    QPixmap upgradeNormalGrayPixmap(":/images/images/upgrade_normal_gray.png");
    QPixmap upgradeNormalBluePixmap(":/images/images/upgrade_normal_blue.png");
    QPixmap upgradeHoverBluePixmap(":/images/images/upgrade_hover_blue.png");
    QPixmap removeNormalPixmap(":/images/images/remove_normal.png");
    QPixmap removeHoverPixmap(":/images/images/remove_hover.png");
    QPixmap crossPixmap(":/images/images/cross.png");

    // 保持纵横比对按键进行缩放
    QPixmap scaledPausePixmap = pauseNormalPixmap.scaled(60, 60, Qt::KeepAspectRatio);
    QPixmap scaledPauseHoverPixmap = pauseHoverPixmap.scaled(60, 60, Qt::KeepAspectRatio); // 缩放悬停图片
    QPixmap scaledDoubleSpeedPixmap = doubleSpeedNormalPixmap.scaled(120, 120, Qt::KeepAspectRatio);
    QPixmap scaledDoubleSpeedHoverPixmap = doubleSpeedHoverPixmap.scaled(120, 120, Qt::KeepAspectRatio); // 缩放悬停图片

    // 创建暂停和二倍速按钮
    buttons.append(new Button(QPoint(1000, 10), scaledPausePixmap, scaledPauseHoverPixmap, Button::PAUSE));
    buttons.append(new Button(QPoint(800, 10), scaledDoubleSpeedPixmap, scaledDoubleSpeedHoverPixmap, Button::DOUBLE_SPEED));

    // 初始化炮塔坑
    towerPits = TowerPit::createTowerPits();

    // 初始化障碍物
    QString obstaclePaths[8] = {
        ":/images/images/obstacle1.png",
        ":/images/images/obstacle2.png",
        ":/images/images/obstacle3.png",
        ":/images/images/obstacle4.png",
        ":/images/images/obstacle5.png",
        ":/images/images/obstacle6.png",
        ":/images/images/obstacle7.png",
        ":/images/images/obstacle8.png"
    };
    for (int i = 0; i < 8; ++i) {
        Obstacle* obstacle = new Obstacle(towerPits[i]->getPosition(), obstaclePaths[i]);
        obstacles.append(obstacle);
        towerPits[i]->setObstacle(obstacle);
    }
}

// 主窗口类的析构函数实现，释放动态分配的资源
mainwindow::~mainwindow()
{
    for (Enemy* enemy : enemies) {
        delete enemy;
    }
    for (Tower* tower : towers) {
        delete tower;
    }
    for (Button* button : buttons) {
        delete button;
    }
    for (Obstacle* obstacle : obstacles) {
        delete obstacle;
    }
    for (TowerPit* pit : towerPits) {
        delete pit;
    }
    delete radish;
    delete money;
    delete ui;
}

// 绘制事件处理函数的实现，用于绘制游戏界面元素
void mainwindow::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event);
    QPainter painter(this);
    // 绘制游戏地图
    painter.drawPixmap(0, 0, mapPixmap.scaled(width(), height()));

    // 绘制所有敌人
    for (Enemy* enemy : enemies) {
        enemy->draw(&painter);
    }
    // 绘制炮塔坑
    QPixmap pitPixmap(":/images/images/tower_pit.png"); // 假设的炮塔坑贴图路径
    for (TowerPit* pit : towerPits) {
        painter.drawPixmap(pit->getPosition(), pitPixmap.scaled(80,80,Qt::KeepAspectRatio));
    }
    // 绘制所有炮塔
    for (Tower* tower : towers) {
        tower->draw(&painter, enemies);
        // 绘制炮塔发射的子弹
        for (Bullet* bullet : tower->getBullets()) {
            bullet->draw(&painter);
        }
    }

    // 绘制萝卜
    radish->draw(&painter);

    // 绘制所有障碍物
    for (Obstacle* obstacle : obstacles) {
        obstacle->draw(&painter);
    }

    // 如果需要显示创建炮塔的按钮，则绘制它们
    if (showButtons) {
        QPixmap cannonButtonPixmap(":/images/images/cannon_button.png");
        QPixmap poopButtonPixmap(":/images/images/poop_button.png");
        QPixmap starButtonPixmap(":/images/images/star_button.png");

        int buttonSize = 100;
        int gap = 10;

        // 绘制加农炮炮塔选择按钮
        painter.drawPixmap(clickPos.x(), clickPos.y(), cannonButtonPixmap.scaled(buttonSize, buttonSize));
        // 绘制便便炮塔选择按钮
        painter.drawPixmap(clickPos.x() + buttonSize + gap, clickPos.y(), poopButtonPixmap.scaled(buttonSize, buttonSize));
        // 绘制星星炮塔选择按钮
        painter.drawPixmap(clickPos.x() + 2 * (buttonSize + gap), clickPos.y(), starButtonPixmap.scaled(buttonSize, buttonSize));
    }

    // 如果有选中的炮塔，则绘制该炮塔的升级和移除按钮
    if (selectedTower) {
        QPixmap upgradePixmap;
        // 根据金币数量选择升级按钮的图片
        if (money->canAfford(selectedTower->getUpgradeCost())) {
            upgradePixmap = QPixmap(":/images/images/upgrade_normal_blue.png");
        } else {
            upgradePixmap = QPixmap(":/images/images/upgrade_normal_gray.png");
        }
        // 计算升级按钮的位置并绘制
        QPoint upgradePos(selectedTower->getPosition().x(), selectedTower->getPosition().y() - upgradePixmap.height());
        painter.drawPixmap(upgradePos, upgradePixmap);

        // 加载移除按钮的图片
        QPixmap removePixmap(":/images/images/remove_normal.png");
        // 计算移除按钮的位置并绘制
        QPoint removePos(selectedTower->getPosition().x(), selectedTower->getPosition().y() + selectedTower->getPixmap().height());
        painter.drawPixmap(removePos, removePixmap);
    }

    // 如果游戏结束，绘制游戏结束图片
    if (isGameOver) {
        painter.drawPixmap((width() - gameOverPixmap.width()) / 2, (height() - gameOverPixmap.height()) / 2, gameOverPixmap);
    }

    // 绘制金币图标和当前金钱数量
    painter.setPen(Qt::white);
    painter.drawPixmap(10, 20, coinPixmap.scaled(60, 60));
    painter.drawText(80, 60, QString("Money: %1").arg(money->getAmount()));

    // 绘制所有按钮
    for (Button* button : buttons) {
        button->draw(&painter);
    }
}

// 定时器事件处理函数的实现，处理游戏的定时逻辑
void mainwindow::timerEvent(QTimerEvent *event)
{
    if (event->timerId() == waveTimerId) {
        if (isGameOver) {
            return;
        }

        for (int i = 0; i < gameSpeed; ++i) {
            // 增加游戏已过去的时间
            elapsedTime += 100;

            // 第一波怪物生成逻辑
            if (currentWave == 0 && elapsedTime <= 20000) {
                if (elapsedTime % 4000 == 0) {
                    generateMonster(Enemy::Monster1);
                }
                if (elapsedTime % 5000 == 0) {
                    generateMonster(Enemy::Monster2);
                }
            } else if (elapsedTime == 60000) {
                // 进入第二波
                currentWave = 1;
            }

            // 第二波怪物生成逻辑
            if (currentWave == 1) {
                if (elapsedTime - 60000 <= 20000) {
                    if ((elapsedTime - 60000) % 4000 == 0) {
                        generateMonster(Enemy::Monster3);
                    }
                    if ((elapsedTime - 60000) % 5000 == 0) {
                        generateMonster(Enemy::Monster2);
                    }
                } else if (elapsedTime - 60000 == 30000) {
                    generateMonster(Enemy::MonsterBoss);
                }
            }

            // 移动所有敌人
            for (auto it = enemies.begin(); it != enemies.end(); ) {
                Enemy* enemy = *it;
                enemy->move();
                if (enemy->getHealth() <= 0 || isEnemyAtEnd(enemy)) {
                    if (enemy->getHealth() <= 0) {
                        // 根据不同类型的敌人增加不同数量的金钱
                        switch (enemy->getType()) {
                        case Enemy::Monster1:
                            money->earn(50);
                            break;
                        case Enemy::Monster2:
                            money->earn(80);
                            break;
                        case Enemy::Monster3:
                            money->earn(80);
                            break;
                        case Enemy::MonsterBoss:
                            money->earn(500);
                            break;
                        }
                    }
                    if (isEnemyAtEnd(enemy)) {
                        // 检查敌人是否与萝卜碰撞
                        checkEnemyCollideWithRadish();
                    }
                    delete enemy;
                    it = enemies.erase(it); // 移除死亡或到达终点的敌人
                } else {
                    ++it;
                }
            }

            // 炮塔攻击敌人
            for (Tower* tower : towers) {
                if (selectedObstacle && tower->isInRange(selectedObstacle->getPosition())) {
                    tower->attackObstacle(selectedObstacle);
                } else {
                    tower->attack(enemies);
                }
                tower->updateBullets();
            }

            // 障碍物被攻击处理
            for (auto it = obstacles.begin(); it != obstacles.end(); ) {
                Obstacle* obstacle = *it;
                if (obstacle->getHealth() <= 0) {
                    // 障碍物被摧毁处理
                    for (TowerPit* pit : towerPits) {
                        if (pit->getObstacle() == obstacle) {
                            pit->setObstacle(nullptr);
                            break;
                        }
                    }
                    delete obstacle;
                    it = obstacles.erase(it);
                } else {
                    ++it;
                }
            }

            // 如果萝卜生命值为0，游戏结束
            if (radish->getHealth() <= 0) {
                isGameOver = true;
            }
        }

        // 更新界面
        update();
    }
}

// 鼠标按下事件处理函数的实现，处理鼠标点击操作
void mainwindow::mousePressEvent(QMouseEvent *event)
{
    if (isGameOver) {
        return;
    }

    QPoint clickPos = event->pos();

    // 检查是否点击了全局按钮（暂停、二倍速）
    for (Button* button : buttons) {
        if (button->isClicked(clickPos)) {
            handleButtonClick(button->getType());
            update(); // 强制更新界面，确保贴图刷新
            return;
        }
    }

    // 检查是否点击了障碍物
    for (Obstacle* obstacle : obstacles) {
        QRect obstacleRect(obstacle->getPosition().toPoint(), obstacle->getPixmap().size());
        if (obstacleRect.contains(clickPos)) {
            if (selectedObstacle) {
                selectedObstacle->setSelected(false);
            }
            selectedObstacle = obstacle;
            selectedObstacle->setSelected(true);
            update();
            return;
        }
    }

    for (TowerPit* pit : towerPits) {
        if (pit->getRect().contains(clickPos) && !pit->hasTower() && !pit->hasObstacle()) {
            this->clickPos = pit->getPosition();
            showButtons = true;
            update();
            return;
        }
    }

    // 如果有选中的炮塔，检查是否点击了升级或移除按钮
    if (selectedTower) {
        QPixmap upgradePixmap;
        // 根据金币数量选择升级按钮的图片
        if (money->canAfford(selectedTower->getUpgradeCost())) {
            upgradePixmap = QPixmap(":/images/images/upgrade_normal_blue.png");
        } else {
            upgradePixmap = QPixmap(":/images/images/upgrade_normal_gray.png");
        }
        // 计算升级按钮的矩形区域
        QPoint upgradePos(selectedTower->getPosition().x(), selectedTower->getPosition().y() - upgradePixmap.height());
        QRect upgradeRect(upgradePos, upgradePixmap.size());

        // 加载移除按钮的图片
        QPixmap removePixmap(":/images/images/remove_normal.png");
        // 计算移除按钮的矩形区域
        QPoint removePos(selectedTower->getPosition().x(), selectedTower->getPosition().y() + selectedTower->getPixmap().height());
        QRect removeRect(removePos, removePixmap.size());

        // 如果点击了升级按钮且金币足够，进行升级操作并取消选中
        if (upgradeRect.contains(clickPos) && money->canAfford(selectedTower->getUpgradeCost())) {
            selectedTower->upgrade();
            money->spend(selectedTower->getUpgradeCost());
            selectedTower = nullptr; // 取消选中
            update();
            return;
        }

        // 如果点击了移除按钮，移除炮塔并取消选中
        if (removeRect.contains(clickPos)) {
            money->earn(selectedTower->getSellPrice());
            auto it = std::find(towers.begin(), towers.end(), selectedTower);
            if (it != towers.end()) {
                delete *it;
                towers.erase(it);
            }
            selectedTower = nullptr; // 取消选中
            update();
            return;
        }
    }

    // 如果显示了选项按钮，检查是否点击了某个选项按钮
    if (showButtons) {
        QPixmap cannonButtonPixmap(":/images/images/cannon_button.png");
        QPixmap poopButtonPixmap(":/images/images/poop_button.png");
        QPixmap starButtonPixmap(":/images/images/star_button.png");

        int buttonSize = 100;
        int gap = 10;

        // 定义三个选项按钮的矩形区域
        QRect cannonButtonRect(this->clickPos.x(), this->clickPos.y(), buttonSize, buttonSize);
        QRect poopButtonRect(this->clickPos.x() + buttonSize + gap, this->clickPos.y(), buttonSize, buttonSize);
        QRect starButtonRect(this->clickPos.x() + 2 * (buttonSize + gap), this->clickPos.y(), buttonSize, buttonSize);

        // 标记是否点击了有效按钮
        bool validButtonClicked = false;

        // 如果点击了加农炮选项按钮
        if (cannonButtonRect.contains(clickPos)) {
            if (money->canAfford(Tower::getCost(Tower::CANNON))) {
                towers.push_back(new Tower(Tower::CANNON, this->clickPos));
                money->spend(Tower::getCost(Tower::CANNON));
                validButtonClicked = true;
            }
        }
        // 如果点击了便便炮塔选项按钮
        else if (poopButtonRect.contains(clickPos)) {
            if (money->canAfford(Tower::getCost(Tower::POOP))) {
                towers.push_back(new Tower(Tower::POOP, this->clickPos));
                money->spend(Tower::getCost(Tower::POOP));
                validButtonClicked = true;
            }
        }
        // 如果点击了星星炮塔选项按钮
        else if (starButtonRect.contains(clickPos)) {
            if (money->canAfford(Tower::getCost(Tower::STAR))) {
                towers.push_back(new Tower(Tower::STAR, this->clickPos));
                money->spend(Tower::getCost(Tower::STAR));
                validButtonClicked = true;
            }
        }

        // 无论是否成功放置炮塔，点击按钮后都隐藏选项按钮
        showButtons = false;
        update(); // 刷新界面

        // 如果点击了有效按钮，直接返回，避免其他逻辑处理
        if (validButtonClicked) {
            return;
        }
    }
}

// 生成指定类型的怪物
void mainwindow::generateMonster(int type)
{
    enemies.append(new Enemy(static_cast<Enemy::Type>(type)));
}

// 检查敌人是否到达终点
bool mainwindow::isEnemyAtEnd(Enemy* enemy)
{
    QPointF endPoint = enemy->getPathPoints().last();
    return enemy->getPosition() == endPoint;
}

// 检查敌人是否与萝卜碰撞，并处理萝卜的生命值减少
void mainwindow::checkEnemyCollideWithRadish()
{
    for (Enemy* enemy : enemies) {
        if (isEnemyAtEnd(enemy)) {
            switch (enemy->getType()) {
            case Enemy::Monster1:
                radish->takeDamage(1);
                break;
            case Enemy::Monster2:
            case Enemy::Monster3:
                radish->takeDamage(2);
                break;
            case Enemy::MonsterBoss:
                radish->takeDamage(10);
                break;
            }
        }
    }
}

// 创建指定类型的炮塔
void mainwindow::createTower(Tower::Type type)
{
    if (money->canAfford(Tower::getCost(type))) {
        towers.append(new Tower(type, clickPos));
        money->spend(Tower::getCost(type));
    }
}

// 处理按钮点击事件，根据按钮类型执行相应的操作
void mainwindow::handleButtonClick(Button::ButtonType type)
{
    switch (type) {
    case Button::PAUSE:
        if (waveTimerId != -1) {
            killTimer(waveTimerId);
            waveTimerId = -1;
        } else {
            if (gameSpeed == 1) {
                waveTimerId = startTimer(100);
            } else {
                waveTimerId = startTimer(50);
            }
        }
        update();
        break;
    case Button::DOUBLE_SPEED:
        gameSpeed = (gameSpeed == 1) ? 2 : 1;
        if (waveTimerId != -1) {
            killTimer(waveTimerId);
            if (gameSpeed == 1) {
                waveTimerId = startTimer(100);
            } else {
                waveTimerId = startTimer(50);
            }
        }
        update();
        break;
    case Button::CLICK_OBSTACLE:
        break;
    case Button::TOWER_UPGRADE:
        break;
    case Button::TOWER_REMOVE:
        break;
    }
}